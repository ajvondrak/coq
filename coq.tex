\documentclass{beamer}

\usetheme{CambridgeUS}

\setbeamertemplate{theorems}[normal font]
\setbeamertemplate{navigation symbols}{}

\newcommand{\exampletext}[1]{%
  \begin{beamercolorbox}{block title example}#1\end{beamercolorbox}%
}
\renewcommand<>{\fbox}[1]{\alt#2{\beameroriginal{\fbox}{#1}}{#1}}
\newcommand{\gray}[1]{\textcolor{gray}{#1}}

\usepackage{listings,lstlangcoq,bold-extra}
\lstset{basicstyle=\ttfamily,language=Coq}

\usepackage{graphics}

\title{What's in a Proof?}
\author{Alex Vondrak}
\institute{Cal Poly Pomona}
\titlegraphic{\includegraphics[height=3cm]{four-lights.jpg}}

\begin{document}

\maketitle

\begin{frame}{An Anecdote}
  % Classmates: whinge about proving things in such minute detail that you'd
  % even need to prove (something like) 2 + 2 = 4.
  % Dr. Rich's reaction: "um, no".
  \begin{center}
    \includegraphics[width=10cm]{math-is-hard.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]{The Reason}
  \begin{block}{}
    \begin{lstlisting}[language={},gobble=6]
      Theorem a: 2 + 2 = 4.
    \end{lstlisting}
  \end{block}
  \begin{block}{}<2>
    \begin{lstlisting}[language={},gobble=6]
      Proof.
        trivial.
      Qed.
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Coq}
  \begin{center}
    \includegraphics[scale=0.4]{coq.png}
  \end{center}
  \begin{itemize}
    \item An \alert{interactive theorem prover} started in 1984
    \item Provides a formal language and environment for mathematical
          definitions, algorithms, theorems, and machine-checked proofs
    \item Language based on a derivative of the \alert{calculus of
          constructions} (\alert{CoC})
  \end{itemize}
  \begin{example}
    \begin{lstlisting}[gobble=6,escapechar=|]
      Theorem two_and_two_make_four: 2 + 2 = 4.
      Proof.
        |\alt<2>{\alert{auto 1.}}{trivial.}|
      Qed.
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]{Proof Automation}
  \begin{block}{Rough Algorithm}
    \begin{lstlisting}[language={},
                       morekeywords={if,then,foreach,in,try},
                       mathescape=true,
                       escapechar=|,
                       gobble=6]
      auto n =
        if |\normalfont no more subgoals| then
          |\exampletext{success}|
        if n == 0 then
          |\alert{failure}|
        foreach |\normalfont term| in |\fbox{$hypotheses \cup hints$}|:
          try
            |\fbox{apply \text{\normalfont term}.}|
            foreach |\text{\normalfont subgoal generated}|:
              auto (n - 1) |\normalfont on that subgoal|
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile,t]{\texttt{apply} term\texttt{.}}
  \begin{itemize}
    \item Tries to \alert{unify} the goal with the conclusion of the
          \alert{type} of ``term''
    \item Returns \alert{subgoals}---premises of the type of ``term''
  \end{itemize}
  \begin{onlyenv}<1>
    \begin{example}[At the Coq Top-Level]
      \begin{lstlisting}[gobble=8,escapechar=|]
        |\gray{Coq <}| Example ex: (1=2 -> 2=1) -> (2=1 -> 1=2) -> 1=2.
        |\gray{1 subgoal}|

          |\gray{============================}|
           |\gray{(1 = 2 -> 2 = 1) -> (2 = 1 -> 1 = 2) -> 1 = 2}|

        |\gray{ex <}|
      \end{lstlisting}
    \end{example}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{example}[At the Coq Top-Level]
      \begin{lstlisting}[gobble=8,escapechar=|]
          |\gray{============================}|
           |\gray{(1 = 2 -> 2 = 1) -> (2 = 1 -> 1 = 2) -> 1 = 2}|

        |\gray{ex <}| intros.
        |\gray{1 subgoal}|

          |\gray{H : 1 = 2 -> 2 = 1}|
          |\gray{H0 : 2 = 1 -> 1 = 2}|
          |\gray{============================}|
           |\gray{1 = 2}|
      \end{lstlisting}
    \end{example}
  \end{onlyenv}
  \begin{onlyenv}<3>
    \begin{example}[At the Coq Top-Level]
      \begin{lstlisting}[gobble=8,escapechar=|]
          |\gray{H : 1 = 2 -> 2 = 1}|
          |\gray{H0 : 2 = 1 -> 1 = 2}|
          |\gray{============================}|
           |\gray{1 = 2}|

        |\gray{ex <}| apply H.
        |\gray{Toplevel input, characters 6-7:}|
        |\gray{> apply H.}|
        |\gray{>}|      |\gray{\^{}}|
        |\gray{Error: Impossible to unify "2 = 1" with "1 = 2".}|
      \end{lstlisting}
    \end{example}
  \end{onlyenv}
  \begin{onlyenv}<4>
    \begin{example}[At the Coq Top-Level]
      \begin{lstlisting}[gobble=8,escapechar=|]
        |\gray{ex <}| apply H0.
        |\gray{1 subgoal}|

          |\gray{H : 1 = 2 -> 2 = 1}|
          |\gray{H0 : 2 = 1 -> 1 = 2}|
          |\gray{============================}|
           |\gray{2 = 1}|

        |\gray{ex <}|
      \end{lstlisting}
    \end{example}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Hints and Hypotheses}
  \begin{lstlisting}[gobble=4,escapechar=|]
    |\gray{Coq <}| Theorem two_and_two_make_four: 2 + 2 = 4.
    |\gray{1 subgoal}|

      |\gray{============================}|
       |\gray{2 + 2 = 4}|

    |\gray{two\_and\_two\_make\_four <}| Print Hint.
  \end{lstlisting}
  \small
  \begin{lstlisting}[language={},gobble=4]
    Applicable Hints :
    [...]
    In the database core:
      apply mult_n_O(0) apply mult_n_Sm(0) apply plus_n_O(0)
      apply eq_refl(0) apply plus_n_Sm(0)
      apply eq_add_S ; trivial(1) apply eq_sym ; trivial(1)
      apply f_equal (A:=nat)(1) apply f_equal2 mult(2)
      apply f_equal2 (A1:=nat) (A2:=nat)(2)
    [...]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Hints and Hypotheses}{Which Hint?}
  \begin{lstlisting}[gobble=4,escapechar=|]
    |\gray{two\_and\_two\_make\_four <}| Proof.

    |\gray{two\_and\_two\_make\_four <}| info trivial.
     |\gray{==}| apply eq_refl.

    |\gray{Proof completed.}|

    |\gray{two\_and\_two\_make\_four}| < Qed.
    |\gray{info trivial.}|

    |\gray{two\_and\_two\_make\_four is defined}|

    |\gray{Coq <}|
  \end{lstlisting}
\end{frame}

\end{document}
